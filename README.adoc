= Nadja (WIP)

An event-driven simulator specifically designed for digital circuits.

== TODO

* Add a stop function
* Add a notion of time scale (ps, ns...)
* Enable submodules
* RAM block
* FSM
* Moore & Mealy machine
* Generate trace files
* macros for concat
* Generate SystemVerilog code

== Usage (WIP)

Complete examples are available in the `examples/` directory:

* Fibonacci LFSR

=== Channels

Each node of a circuit can be represented by a variable implementing the `Channel<T>` trait (with `T`, the actual type of the circuit node). For instance, the `Signal<T>` and the `Wire<T>` structures both implement the `Channel<T>` trait. This trait is hidden by the library and you usually don't have to think about it.

=== Combinational logic

In Nadja, the Combinational logic of a circuit is described using the functional semantic.

Since the output of a combinational circuit is a pure function of the present inputs only, you can describe this kind of circuit by creating a function preceded by the attribute-like macro `#[channel]`. This kind of function is called a *Channel function*. The output type of the function should be the same as the output of your combinational circuit.

The name of channel functions should be written using the `UpperCamelCase`.

[source, rust]
----
#[channel]
fn MyChannelFunc(input1: type_i1, input2: type_i2) -> type_o {
    //Body of the channel function
}
----

You can use the `new` constructor function preceded by the channel function's name to instantiate the combinational circuit. This instance implements the `Channel<T>` trait. For each input, you have to provide a reference that implements the `Channel<T>` trait representing the actual input of your combinational circuit.

[source, rust]
----
let output = MyChannelFunc::new(&input1, &input2);
//inpu1,input2 & output implement the Channel<T> trait
----

=== Modules

*Example:*

[source, rust]
----
#[module]
struct MyModule {
    //Parameters
    P1: Param<type_1>,

    //Input
    a_i: Input<type_i1>,
    rst_ni: Input<bool>,

    //Output
    x_o: Output<type_o1>,
    y_o: Output<type_o1>,

    //Channel function
    x_d: CFunc1,
    y: CFunc2,

    //Process
    x_q: RegRst<type_1>,
}
----

[source, rust]
----
#[comb]
fn MyModule() {
    Self {
        x_d: CFunc1::new(&sig.x_q),
        y: CFunc2::new(input.a_i),
    }
}
----

[source, rust]
----
#[proc]
fn MyModule() {
    Self {
        x_q: RegRst::new(&comb.x_d, &sig.x_q, input.rst_ni, &input.P1),
    }
}
----

[source, rust]
----
#[out]
fn MyModule() {
    Self {
        x_o: &sig.x_q,
        y_o: &comb.y,
    }
}
----
